<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸ƒæ—¥åœ’ä¸ - æœ€çµ‚ç©©å®šç‰ˆ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        :root {
            --bg-deep: #1a252f; --bg-main: #2c3e50; --text-main: #ecf0f1;
            --text-muted: #bdc3c7; --accent-blue: #3498db; --accent-green: #2ecc71;
            --accent-purple: #9b59b6; --accent-red: #e74c3c; --accent-orange: #f39c12;
            --border-color: #ecf0f1; --card-bg: #34495e; --slot-bg: rgba(0,0,0,0.2);
            --slot-hover-bg: rgba(46, 204, 113, 0.2); --slot-used-bg: rgba(0,0,0,0.5);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; width: 100%; overflow: hidden; }
        body { 
            font-family: 'Press Start 2P', 'Microsoft JhengHei', sans-serif; 
            background: var(--bg-main); color: var(--text-main); image-rendering: pixelated; 
        }

        .game-container { 
            width: 100%; max-height: 100vh; display: flex; flex-direction: column; 
            overflow-y: auto; padding-bottom: 20px;
        }
        .screen { width: 100%; display: flex; flex-direction: column; }
        .start-screen, .end-screen { 
            text-align: center; padding: 40px; background: var(--bg-deep); 
            justify-content: center; align-items: center; min-height: 100vh;
        }
        .hidden { display: none !important; }

        .game-title { font-size: clamp(1.5em, 4vw, 2.5em); margin-bottom: 20px; line-height: 1.4; }
        .game-subtitle { font-size: clamp(0.8em, 2vw, 1em); color: var(--text-muted); margin-bottom: 30px; }
        .start-button, .restart-button {
            border: 2px solid var(--border-color); padding: 10px 25px; font-size: clamp(0.8em, 1.5vw, 1em);
            cursor: pointer; transition: all 0.2s; font-weight: bold; color: var(--text-main); background: transparent;
        }
        .start-button { border-color: var(--accent-green); color: var(--accent-green); }
        .start-button:hover { background: var(--accent-green); color: var(--bg-deep); }
        .restart-button:hover { background: var(--accent-blue); }
        
        .gameplay-screen { padding: 10px; gap: 10px; min-height: 100vh; }
        
        .world-board {
            flex-shrink: 0; padding: 10px; background: var(--bg-deep); border: 2px solid var(--border-color);
            display: flex; justify-content: space-around; align-items: center; gap: 15px;
        }
        .garden-display { text-align: center; }
        .pixel-art-garden { 
            font-family: 'Courier New', monospace; font-size: clamp(10px, 1.2vw, 14px); 
            line-height: 1.2; white-space: pre; transition: opacity 0.5s;
        }
        .character-display { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; min-width: 120px;}
        .character-slot { text-align: center; position: relative; }
        .character-avatar-text { 
            font-size: clamp(0.7em, 1.2vw, 0.9em); padding: 8px 12px; 
            border: 2px solid #7f8c8d; color: #7f8c8d; transition: all 0.3s;
        }
        .character-slot.met .character-avatar-text { 
            color: var(--text-main); border-color: var(--accent-green); 
            background: rgba(46, 204, 113, 0.1); 
        }

        .main-workspace { flex-grow: 1; display: flex; flex-direction: column; gap: 10px; }
        
        .info-panel {
            flex-shrink: 0; display: flex; justify-content: space-between; align-items: center;
            padding: 10px 15px; background: var(--bg-deep); border: 2px solid var(--border-color);
        }
        .day-counter { font-size: clamp(0.9em, 1.5vw, 1em); }
        .stats-dashboard { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;}
        .stat-item { text-align: right; width: clamp(70px, 10vw, 80px); }
        .stat-label { font-size: clamp(0.5em, 1vw, 0.6em); color: var(--text-muted); margin-bottom: 3px; display: block; }
        .stat-bar { width: 100%; height: 5px; background: rgba(0,0,0, 0.3); border: 1px solid var(--text-muted); }
        .stat-fill { height: 100%; transition: width 0.5s ease; }
        .stat-garden { background: var(--accent-green); } 
        .stat-energy { background: var(--accent-orange); } 
        .stat-favor { background: var(--accent-red); } 
        .stat-patience { background: var(--accent-blue); }

        .event-panel {
            flex-shrink: 0; background: var(--bg-deep); border: 2px solid var(--border-color);
            padding: 15px; text-align: center; max-height: 200px; overflow-y: auto; display: flex;
            flex-direction: column; justify-content: center; transition: opacity 0.3s;
        }
        .event-text { font-size: clamp(0.8em, 1.5vw, 0.9em); line-height: 1.6; margin-bottom: 10px; }
        .event-character { color: var(--accent-purple); font-size: clamp(0.7em, 1.2vw, 0.8em); }
        .event-choices { display: flex; justify-content: center; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
        .event-choice-btn {
            padding: 8px 15px; background: var(--card-bg); color: var(--text-main);
            border: 2px solid var(--accent-blue); cursor: pointer; font-size: clamp(0.7em, 1.2vw, 0.8em);
            transition: all 0.2s; border-radius: 4px;
        }
        .event-choice-btn:hover { background: var(--accent-blue); }
        
        .verb-slots {
            flex-grow: 1; display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;
            padding: 15px; background: var(--bg-deep); border: 2px solid var(--border-color);
            min-height: 80px; position: relative;
        }
        .verb-slot {
            background: var(--slot-bg); border: 2px dashed var(--text-muted);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: all 0.3s; min-height: 80px; flex: 1; position: relative;
        }
        .verb-slot.current { 
            border-color: var(--accent-blue); background: rgba(52, 152, 219, 0.1); 
        }
        .verb-slot.drop-target {
            border-color: var(--accent-green);
            background: var(--slot-hover-bg);
            transform: scale(1.05);
        }
        .verb-slot.used { 
            background: var(--slot-used-bg); border-style: solid; opacity: 0.8;
            border-color: var(--accent-green);
        }
        .verb-slot-time { font-size: clamp(0.8em, 1.5vw, 0.9em); color: var(--text-muted); margin-bottom: 8px; }
        .verb-slot-action { font-size: clamp(0.6em, 1vw, 0.7em); color: var(--accent-green); text-align: center; }

        .hand-area {
            flex-shrink: 0; display: flex; justify-content: center; align-items: center; gap: 8px;
            padding: 15px; background: var(--bg-deep); border: 2px solid var(--border-color); 
            min-height: 110px; flex-wrap: wrap; overflow-x: hidden; position: relative;
        }
        .card {
            width: clamp(60px, 10vw, 70px); height: clamp(90px, 15vw, 100px); 
            background: var(--card-bg); border: 2px solid var(--border-color);
            display: flex; flex-direction: column; justify-content: space-between; align-items: center;
            padding: 6px; cursor: grab; transition: transform 0.2s, opacity 0.3s;
            position: relative; touch-action: none; user-select: none;
        }
        .card.dragging { 
            cursor: grabbing; 
            transform: scale(1.1); 
            opacity: 0.9; 
            z-index: 1000;
            pointer-events: none;
            position: fixed;
        }
        .card-art { font-size: clamp(1.5em, 3vw, 1.8em); pointer-events: none; }
        .card-name { font-size: clamp(0.5em, 0.8vw, 0.6em); pointer-events: none; text-align: center; }
        .card-durability { 
            position: absolute; bottom: 2px; left: 4px; font-size: clamp(0.4em, 0.7vw, 0.5em); 
            color: var(--accent-orange); 
        }
        
        .card.item { border-color: var(--accent-orange); }
        .card.action { border-color: var(--accent-green); }

        .day-transition {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: white; display: flex; flex-direction: column;
            justify-content: center; align-items: center; font-size: clamp(1em, 2vw, 1.2em);
            opacity: 0; transition: opacity 0.5s; pointer-events: none; z-index: 100;
            padding: 20px; text-align: left;
        }
        .day-transition.show { opacity: 1; }
        .day-transition-title { font-size: clamp(1.5em, 3vw, 1.8em); margin-bottom: 20px; text-align: center; }
        .day-transition-diary { white-space: pre-wrap; line-height: 1.8; max-width: 600px; }

        .ending-text { white-space: pre-wrap; margin: 20px 0; line-height: 1.8; }

        @media (max-width: 768px) {
            .verb-slots { grid-template-columns: repeat(2, 1fr); }
            .hand-area { justify-content: flex-start; }
        }
        @media (max-width: 480px) {
            .world-board { flex-direction: column; gap: 10px; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="startScreen" class="screen start-screen">
            <h1 class="game-title">ä¸ƒæ—¥åœ’ä¸</h1>
            <p class="game-subtitle">å…©å¤©å¡ç‰ŒåŸå‹</p>
            <button class="start-button" id="startBtn">é–‹å§‹éŠæˆ²</button>
        </div>
        
        <div id="gameplayScreen" class="screen gameplay-screen hidden">
            <div class="world-board">
                <div class="character-display">
                    <div id="char-guard" class="character-slot"><div class="character-avatar-text">???</div></div>
                </div>
                <div class="garden-display"><pre id="pixelArtGarden" class="pixel-art-garden"></pre></div>
                <div class="character-display">
                    <div id="char-maid" class="character-slot hidden"><div class="character-avatar-text">???</div></div>
                    <div id="char-king" class="character-slot hidden"><div class="character-avatar-text">???</div></div>
                </div>
            </div>

            <div class="main-workspace">
                <div class="info-panel">
                    <div id="dayCounter" class="day-counter"></div>
                    <div class="stats-dashboard">
                        <div class="stat-item"><span class="stat-label">èŠ±åœ’</span><div class="stat-bar"><div id="statGarden" class="stat-fill stat-garden"></div></div></div>
                        <div class="stat-item"><span class="stat-label">é«”åŠ›</span><div class="stat-bar"><div id="statEnergy" class="stat-fill stat-energy"></div></div></div>
                        <div class="stat-item"><span class="stat-label">å¥½æ„Ÿ</span><div class="stat-bar"><div id="statFavor" class="stat-fill stat-favor"></div></div></div>
                        <div class="stat-item"><span class="stat-label">è€å¿ƒ</span><div class="stat-bar"><div id="statPatience" class="stat-fill stat-patience"></div></div></div>
                    </div>
                </div>
                <div id="eventPanel" class="event-panel">
                    <div id="eventText" class="event-text"></div>
                    <div id="eventCharacter" class="event-character"></div>
                    <div id="eventChoices" class="event-choices"></div>
                </div>
                <div id="verbSlots" class="verb-slots"></div>
            </div>
            <div id="handArea" class="hand-area"></div>
        </div>

        <div id="endScreen" class="screen end-screen hidden">
            <h2 id="endingTitle" class="ending-title"></h2>
            <div id="endingText" class="ending-text"></div>
            <button class="restart-button" id="restartBtn">é‡æ–°é–‹å§‹</button>
        </div>
        
        <div id="dayTransition" class="day-transition">
            <div id="dayTransitionTitle" class="day-transition-title"></div>
            <div id="dayTransitionDiary" class="day-transition-diary"></div>
        </div>
    </div>

    <script>
        // --- GLOBAL STATE VARIABLES ---
        let playerStats, gameState, characters, dragState;
        
        const TIME_PERIODS = ['ä¸Šåˆ', 'ä¸­åˆ', 'ä¸‹åˆ', 'å‚æ™š'];
        
        const characterData = {
            guard: { name: 'å®ˆè¡›', met: false },
            maid: { name: 'ä¾å¥³', met: false },
            king: { name: 'åœ‹ç‹', met: false }
        };

        // --- DRAG STATE ---
        dragState = {
            isDragging: false,
            currentCard: null,
            originalPosition: null,
            dragElement: null
        };

        // --- DATA DATABASES ---
        const cardDatabase = {
            'HOE': { name: 'é‹¤é ­', art: 'âš’ï¸', type: 'item', durability: 3, effects: { garden: 10, energy: -5 }, playDescription: 'ä½ æ®å‹•é‹¤é ­ï¼Œæ¸…ç†å‡ºä¸€ç‰‡é›œè‰ï¼ŒèŠ±åœ’çœ‹èµ·ä¾†æ•´æ½”äº†äº›ã€‚', combo: { 'SEED_BAG': { garden: 15, description: 'é…åˆç¨®å­ï¼ŒåœŸåœ°ç…¥ç™¼å‡ºç”Ÿæ©Ÿï¼' } } },
            'SEED_BAG': { name: 'ç¨®å­è¢‹', art: 'ğŸŒ±', type: 'item', effects: { garden: 15 }, playDescription: 'ä½ æ’’ä¸‹ç¨®å­ï¼ŒæœŸå¾…æ–°èŠ½ç ´åœŸè€Œå‡ºã€‚' },
            'WATER': { name: 'æ¸…æ°´', art: 'ğŸ’§', type: 'item', effects: { garden: 5, energy: 5 }, playDescription: 'ä½ ç”¨æ¸…æ°´æ¾†çŒï¼Œæ¤ç‰©é–‹å§‹ç…¥ç™¼æ´»åŠ›ã€‚', combo: { 'PRUNING_SHEARS': { garden: 15, description: 'ä¿®å‰ªå¾Œæ¾†æ°´ï¼ŒèŠ±åœ’æ›´åŠ æ•´é½Šï¼' } } },
            'PRUNING_SHEARS': { name: 'ä¿®æå‰ª', art: 'âœ‚ï¸', type: 'item', durability: 2, effects: { garden: 15, patience: -5 }, playDescription: 'ä½ å°å¿ƒä¿®å‰ªï¼Œæ¤ç‰©æ›´æ•´é½Šï¼Œä½†åœ‹ç‹ä¼¼ä¹ä¸è€ç…©äº†ã€‚' },
            'HERBAL_TEA': { name: 'è‰è—¥èŒ¶', art: 'â˜•', type: 'item', effects: { energy: 15, favor: 5 }, playDescription: 'ä½ å–ä¸‹è‰è—¥èŒ¶ï¼Œæ„Ÿåˆ°ç²¾ç¥ç…¥ç™¼ï¼Œä¾å¥³å¾®ç¬‘é»é ­ã€‚' },
            'REST': { name: 'ä¼‘æ¯', art: 'ğŸ˜´', type: 'action', effects: { energy: 25 }, playDescription: 'ä½ å°æ†©ç‰‡åˆ»ï¼Œæ„Ÿè¦ºé«”åŠ›æ¢å¾©äº†ã€‚' },
            'EXPLORE': { name: 'æ¢ç´¢', art: 'ğŸ”', type: 'action', effects: { energy: -10, triggerEvent: 'FOUND_WATER' }, playDescription: 'ä½ å››è™•æ¢ç´¢ï¼Œå°‹æ‰¾æœ‰ç”¨çš„è³‡æºã€‚' },
            'FLOWER_SEEDS': { name: 'èŠ±ç¨®', art: 'ğŸŒ¸', type: 'item', charges: 2, effects: { garden: 10, favor: 5 }, playDescription: 'ä½ ç¨®ä¸‹èŠ±ç¨®ï¼ŒèŠ±åœ’å¢æ·»äº†å¹¾åˆ†è‰²å½©ã€‚' },
            'OLD_COINS': { name: 'èˆŠéŠ…å¹£', art: 'ğŸ’°', type: 'item', durability: 1, effects: { favor: 10 }, playDescription: 'ä½ å°‡å¹¾æšèˆŠéŠ…å¹£å¡çµ¦å®ˆè¡›ï¼Œä»–ä¸å‹•è²è‰²åœ°æ”¶ä¸‹äº†ã€‚' },
            'GARDEN_MAP': { name: 'èŠ±åœ’åœ°åœ–', art: 'ğŸ—ºï¸', type: 'item', durability: 1, effects: { triggerEvent: 'HIDDEN_PATH' }, playDescription: 'ä½ å±•é–‹åœ°åœ–ï¼Œç™¼ç¾äº†ä¸€æ¢éš±ç§˜å°å¾‘ã€‚', unique: true },
        };

        const eventDatabase = {
            'DAY_1_START': { text: 'ä½ è¢«å®ˆè¡›ç²—æš´åœ°æ¨å…¥èŠ±åœ’ã€‚"ä¸ƒå¤©ï¼Œè®“é€™è£¡é–‹èŠ±ï¼Œä¸ç„¶ä½ çš„è…¦è¢‹å°±å¾—é–‹èŠ±ã€‚" ä»–æ‰“çµ¦ä½ ä¸€æŠŠèˆŠé‹¤é ­å’Œä¸€è¢‹ç¨®å­ï¼Œ"åˆ¥å·æ‡¶ã€‚"', character: 'å®ˆè¡›', unlockCharacter: 'guard' },
            'DAY_2_START': { text: 'ç¬¬äºŒå¤©æ¸…æ™¨ï¼Œåœ‹ç‹çªç„¶å‰ä¾†å·¡æŸ¥ï¼Œä»–çšºçœ‰é“ï¼š"é‚„é é ä¸å¤ ï¼" å®ˆè¡›ä¸è€ç…©åœ°æ‰“çµ¦ä½ ä¸€æŠŠä¿®æå‰ªï¼Œ"ç”¨é€™å€‹ï¼Œè®“èŠ±åœ’åƒæ¨£é»ï¼"', character: 'åœ‹ç‹ / å®ˆè¡›', condition: { day: 2 }, effect: { patience: -5 }, unlockCharacter: 'king' },
            'GUARD_WATCHING': { text: 'å®ˆè¡›åœ¨é è™•ç›£è¦–è‘—ä½ çš„ä¸€èˆ‰ä¸€å‹•ï¼Œä»–ä¼¼ä¹å°ä½ çš„é€²å±•ä¸¦ä¸æ»¿æ„ã€‚', character: 'å®ˆè¡›', condition: { day: 1, period: 1 }, effect: { patience: 5 } },
            'FOUND_WATER': { text: 'åœ¨èŠ±åœ’è§’è½ï¼Œä½ ç™¼ç¾äº†ä¸€å€‹ç ´èˆŠä½†é‚„èƒ½ç”¨çš„æ°´äº•ã€‚', choices: [
                { text: 'ä»”ç´°æŸ¥çœ‹äº•åº•ï¼ˆ-5é«”åŠ›ï¼‰', effect: { addCards: ['WATER', 'GARDEN_MAP'], energy: -5 } }, 
                { text: 'åœ¨äº•å£ç¸«éš™æ‘¸ç´¢', effect: { addCards: ['OLD_COINS'], energy: -2 } },
                { text: 'ç›´æ¥æ‰“æ°´é›¢é–‹', effect: { addCards: ['WATER'] } }
            ]},
            'HIDDEN_PATH': { text: 'ä½ æ ¹æ“šåœ°åœ–æ‰¾åˆ°ä¸€æ¢éš±ç§˜å°å¾‘ï¼Œè·¯é‚Šæ•£è½è‘—ä¸€äº›èŠ±ç¨®ï¼', effect: { addCards: ['FLOWER_SEEDS'], garden: 5 } },
            'DAY_2_MAID_INTRO': { text: 'ä¸€ä½ä¾å¥³æ‚„æ‚„é è¿‘ï¼Œéçµ¦ä½ ä¸€æ¯è‰è—¥èŒ¶ï¼š"åœ‹ç‹è„¾æ°£ä¸å¥½ï¼Œä½ å¤šä¿é‡ã€‚å–äº†é€™å€‹ï¼Œå¹¹æ´»æ›´æœ‰å‹ï¼"', character: 'ä¾å¥³', condition: { day: 2, period: 1 }, effect: { addCards: ['HERBAL_TEA'], favor: 10 }, unlockCharacter: 'maid' },
            'KINGS_INSPECTION': { text: 'åœ‹ç‹å†æ¬¡å‡ºç¾ï¼Œæª¢æŸ¥ä½ çš„å·¥ä½œï¼š"é€™èŠ±åœ’å¿…é ˆæ›´æ¼‚äº®ï¼"', character: 'åœ‹ç‹', condition: { day: 2, period: 2 }, effect: { patience: () => playerStats.garden < 40 ? -10 : 0 } },
        };

        const gardenVisuals = {
            weedy: `ğŸŒ¿wğŸŒ¿wğŸŒ¿\nw~w~w~w\nğŸŒ¿wğŸŒ¿wğŸŒ¿\n~w~w~w~`,
            cleared: `...~...\n~.....~\n.......~\n...~....`,
            budding: `ğŸŒ±..ğŸŒ¿.\n...~...\n.ğŸŒ¿.ğŸŒ±..\n...~....`,
            blooming: `ğŸŒ¸ğŸŒ±ğŸŒ¿.\n..ğŸŒ¸..~\n.ğŸŒ¿.ğŸŒ¸ğŸŒ±.\n...~....`
        };

        // --- CORE GAME LOGIC ---
        // é€™æ˜¯ä¿®æ­£å¾Œçš„æ­£ç¢ºç‰ˆæœ¬
function startGame() {
    playerStats = { garden: 10, energy: 80, favor: 20, patience: 70 };
    gameState = { 
        day: 1, periodIndex: 0, hand: [], 
        eventQueue: ['DAY_1_START'], flags: {}, currentEvent: null,
        slotCards: {}, // <--- åœ¨é€™è£¡åŠ ä¸Šé€—è™Ÿ
        dayLog: { actionCounts: {} } // ç”¨æ–¼è¨ˆç®—å¡ç‰Œä½¿ç”¨æ¬¡æ•¸
    };
    characters = JSON.parse(JSON.stringify(characterData));
    showScreen('gameplayScreen');
    setTimeout(initializeDay, 300);
}

        function initializeDay() {
            gameState.dayLog = { actionCounts: {} }; // æ¯å¤©é‡ç½®æ—¥èªŒ
            gameState.hand = gameState.hand.filter(card => (card.durability && card.durability > 0) || (card.charges && card.charges > 0));
            const dayStartingCards = { 1: ['HOE', 'SEED_BAG', 'REST', 'EXPLORE'], 2: ['PRUNING_SHEARS', 'WATER', 'REST', 'EXPLORE'] };
            (dayStartingCards[gameState.day] || []).forEach(addCardToHand);
            updateAllUI();
            renderHandAndSlots();
            processNextEvent();
        }
        
        function startNextDay() {
            gameState.day++;
            gameState.periodIndex = 0;
            gameState.slotCards = {};
            gameState.eventQueue = [`DAY_${gameState.day}_START`];
            Object.keys(gameState.flags).forEach(key => { if (!key.startsWith('unique_')) delete gameState.flags[key]; });
            initializeDay();
        }

        function endDay() {
            const transition = document.getElementById('dayTransition');
            const diaryText = generateDiaryEntry();
            document.getElementById('dayTransitionTitle').textContent = `ç¬¬${gameState.day}å¤©æ—¥è¨˜`;
            document.getElementById('dayTransitionDiary').textContent = diaryText;
            transition.classList.add('show');
            
            setTimeout(() => {
                transition.classList.remove('show');
                if (gameState.day < 2) {
                    startNextDay();
                } else {
                    document.getElementById('endingTitle').textContent = 'å…©å¤©çš„å‹ä½œçµæŸ';
                    document.getElementById('endingText').textContent = diaryText;
                    showScreen('endScreen');
                }
            }, 4500);
        }

        // --- EVENT HANDLING ---
// é€™æ˜¯ processNextEvent å‡½æ•¸çš„å®Œæ•´æ­£ç¢ºç‰ˆæœ¬
function processNextEvent() {
    if (gameState.currentEvent) return;
    if (gameState.eventQueue.length === 0) checkTimeBasedEvents();
    
    if (gameState.eventQueue.length > 0) {
        const eventId = gameState.eventQueue.shift();
        const event = eventDatabase[eventId];
        if (event) {
            gameState.currentEvent = event;
            displayEvent(event);
        }
    } else {
        if (gameState.periodIndex >= TIME_PERIODS.length) {
            endDay();
        } else {
            document.getElementById('eventText').textContent = 'ä½ æ¥ä¸‹ä¾†è¦åšä»€éº¼ï¼Ÿ';
            document.getElementById('eventCharacter').textContent = '';
            document.getElementById('eventChoices').innerHTML = '';
            setTimeout(setupDragAndDrop, 100);
        }
    }
}

        function checkTimeBasedEvents() {
            Object.entries(eventDatabase).forEach(([id, event]) => {
                if (event.condition?.day === gameState.day && event.condition.period === gameState.periodIndex && !gameState.flags[id]) {
                    gameState.eventQueue.push(id);
                    gameState.flags[id] = true;
                }
            });
        }
                
        function checkCardTriggeredEvents(card) {
    const eventId = card.effects?.triggerEvent;
    if (!eventId) return;
    
    const uniqueEventFlag = `unique_event_${eventId}_triggered`;

    // æª¢æŸ¥æ°¸ä¹…æ¨™è¨˜ï¼Œç¢ºä¿äº‹ä»¶åªç™¼ç”Ÿä¸€æ¬¡
    if (!gameState.flags[uniqueEventFlag]) {
        gameState.eventQueue.push(eventId);
        gameState.flags[uniqueEventFlag] = true;

        // --- æ–°å¢çš„ä»£ç¢¼ ---
        // åœ¨ç•¶æ—¥æ—¥èªŒä¸­è¨˜éŒ„ä¸‹é€™å€‹äº‹ä»¶çš„ç™¼ç”Ÿ
        if (!gameState.dayLog.eventsTriggered) {
            gameState.dayLog.eventsTriggered = {};
        }
        gameState.dayLog.eventsTriggered[eventId] = true;
        // --- æ–°å¢ä»£ç¢¼çµæŸ ---
    }
}

        function handleEventChoice(choice) {
    applyEffect(choice.effect);
    gameState.currentEvent = null;
    document.getElementById('eventText').textContent = 'ä½ æ¥ä¸‹ä¾†è¦åšä»€éº¼ï¼Ÿ';
    document.getElementById('eventCharacter').textContent = '';
    document.getElementById('eventChoices').innerHTML = '';
    updateAllUI();
    renderHand();
    setTimeout(() => processNextEvent(), 300);
}
        
        function handleCardPlay(card) {
    // --- æ–°å¢æ—¥èªŒè¨˜éŒ„åŠŸèƒ½é–‹å§‹ ---
    // é€™æ®µä»£ç¢¼æœƒè¨˜éŒ„ç©å®¶ä½¿ç”¨äº†ä»€éº¼å¡ç‰Œï¼Œä»¥ä¾¿æ—¥è¨˜ç”Ÿæˆ
    const cardType = card.id.split('_')[0]; // å¾ 'HOE_12345' ä¸­ç²å– 'HOE'
    const log = gameState.dayLog.actionCounts;
    log[cardType] = (log[cardType] || 0) + 1;
    // --- æ–°å¢æ—¥èªŒè¨˜éŒ„åŠŸèƒ½çµæŸ ---

    let description = card.playDescription;
    const prevCardType = gameState.slotCards[gameState.periodIndex - 1]?.id.split('_')[0];
    if (prevCardType && card.combo?.[prevCardType]) {
        applyEffect(card.combo[prevCardType]);
        description = card.combo[prevCardType].description || description;
    }
    applyEffect(card.effects);

    const cardIndex = gameState.hand.findIndex(c => c.id === card.id);
    if (cardIndex > -1) {
        const cardInHand = gameState.hand[cardIndex];
        let isConsumed = false;
        if (typeof cardInHand.durability !== 'undefined') {
            cardInHand.durability--;
            if (cardInHand.durability <= 0) isConsumed = true;
        } else if (typeof cardInHand.charges !== 'undefined') {
            cardInHand.charges--;
            if (cardInHand.charges <= 0) isConsumed = true;
        } else {
            isConsumed = true; 
        }
        if (isConsumed) gameState.hand.splice(cardIndex, 1);
    }

    // ç«‹å³æ›´æ–°UIï¼Œè®“å¡ç‰Œå¾æ‰‹ç‰Œå€æ¶ˆå¤±
    updateAllUI();
    renderHandAndSlots();

    gameState.slotCards[gameState.periodIndex] = card;
    gameState.periodIndex++;
    
    document.getElementById('eventText').textContent = description;
    document.getElementById('eventCharacter').textContent = '';
    
    checkCardTriggeredEvents(card);
    
    // ç¾åœ¨ setTimeout åªè² è²¬è™•ç†å¾ŒçºŒçš„éŠæˆ²æµç¨‹
    setTimeout(() => {
    // ä¸å†é€²è¡Œåˆ¤æ–·ï¼Œç¸½æ˜¯èª¿ç”¨ processNextEvent è®“å®ƒå»æ±ºå®šä¸‹ä¸€æ­¥åšä»€éº¼
    processNextEvent();
}, 1500);
}

        // --- DRAG AND DROP SYSTEM ---
        function setupDragAndDrop() {
            if (gameState.currentEvent || gameState.periodIndex >= TIME_PERIODS.length) return;
            
            const cards = document.querySelectorAll('.hand-area .card');
            cards.forEach(card => {
                card.addEventListener('mousedown', startDrag);
                card.addEventListener('touchstart', startDrag, { passive: false });
            });
        }

        function startDrag(e) {
            e.preventDefault();
            if (gameState.currentEvent || gameState.periodIndex >= TIME_PERIODS.length) return;
            
            const card = e.currentTarget;
            const cardId = card.id;
            const cardData = gameState.hand.find(c => c.id === cardId);
            if (!cardData) return;

            dragState.isDragging = true;
            dragState.currentCard = cardData;
            dragState.dragElement = card;
            
            // è¨˜éŒ„åŸå§‹ä½ç½®
            const rect = card.getBoundingClientRect();
            dragState.originalPosition = { x: rect.left, y: rect.top };
            
            // è¨­ç½®æ‹–æ‹½ç‹€æ…‹
            card.classList.add('dragging');
            document.body.style.cursor = 'grabbing';
            
            // æ·»åŠ å…¨å±€äº‹ä»¶ç›£è½
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', onDrag, { passive: false });
            document.addEventListener('touchend', endDrag);
            
            // åˆå§‹ä½ç½®è®¾ç½®
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            updateCardPosition(clientX, clientY);
        }

        function onDrag(e) {
            if (!dragState.isDragging) return;
            e.preventDefault();
            
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            
            updateCardPosition(clientX, clientY);
            updateDropTargets(clientX, clientY);
        }

        function updateCardPosition(x, y) {
            if (!dragState.dragElement) return;
            
            const card = dragState.dragElement;
            const cardRect = card.getBoundingClientRect();
            const offsetX = cardRect.width / 2;
            const offsetY = cardRect.height / 2;
            
            card.style.left = (x - offsetX) + 'px';
            card.style.top = (y - offsetY) + 'px';
        }

        function updateDropTargets(x, y) {
            const slots = document.querySelectorAll('.verb-slot');
            let targetSlot = null;
            
            slots.forEach(slot => {
                slot.classList.remove('drop-target');
                
                const rect = slot.getBoundingClientRect();
                const isInside = x >= rect.left && x <= rect.right && 
                                y >= rect.top && y <= rect.bottom;
                
                if (isInside) {
                    const slotIndex = parseInt(slot.id.split('-')[1]);
                    const isCurrent = slotIndex === gameState.periodIndex;
                    const isUsed = slot.classList.contains('used');
                    
                    if (isCurrent && !isUsed) {
                        slot.classList.add('drop-target');
                        targetSlot = slot;
                    }
                }
            });
            
            return targetSlot;
        }

        function endDrag(e) {
            if (!dragState.isDragging) return;
            
            const clientX = e.clientX || (e.changedTouches && e.changedTouches[0].clientX);
            const clientY = e.clientY || (e.changedTouches && e.changedTouches[0].clientY);
            
            const targetSlot = updateDropTargets(clientX, clientY);
            
            // æ¸…ç†äº‹ä»¶ç›‘å¬
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', onDrag);
            document.removeEventListener('touchend', endDrag);
            document.body.style.cursor = '';
            
            // æ¸…ç†æ‰€æœ‰drop-targetæ ·å¼
            document.querySelectorAll('.verb-slot').forEach(slot => {
                slot.classList.remove('drop-target');
            });
            
            if (targetSlot) {
                // æˆåŠŸæ”¾ç½® - æ‰§è¡Œå¸é™„åŠ¨ç”»
                snapToSlot(dragState.dragElement, targetSlot, () => {
                    handleCardPlay(dragState.currentCard);
                    resetDragState();
                });
            } else {
                // æ”¾ç½®å¤±è´¥ - æ‰§è¡Œå›å¼¹åŠ¨ç”»
                bounceBack(dragState.dragElement, () => {
                    resetDragState();
                });
            }
        }

        function snapToSlot(cardElement, slot, callback) {
            const slotRect = slot.getBoundingClientRect();
            const targetX = slotRect.left + slotRect.width / 2;
            const targetY = slotRect.top + slotRect.height / 2;
            
            // å¸é™„åŠ¨ç”»
            cardElement.style.transition = 'all 0.2s ease-out';
            cardElement.style.left = (targetX - cardElement.offsetWidth / 2) + 'px';
            cardElement.style.top = (targetY - cardElement.offsetHeight / 2) + 'px';
            cardElement.style.transform = 'scale(1.1)';
            
            setTimeout(() => {
                cardElement.style.transform = 'scale(1.0)';
                setTimeout(() => {
                    // éšè—å¡ç‰Œå¹¶æ›´æ–°slotæ˜¾ç¤º
                    cardElement.style.opacity = '0';
                    const slotIndex = parseInt(slot.id.split('-')[1]);
                    slot.innerHTML = `<span class="verb-slot-time">${TIME_PERIODS[slotIndex]}</span><span class="verb-slot-action">${dragState.currentCard.name}</span>`;
                    slot.classList.add('used');
                    
                    setTimeout(callback, 100);
                }, 100);
            }, 200);
        }

        function bounceBack(cardElement, callback) {
            // å›å¼¹åŠ¨ç”»
            cardElement.style.transition = 'all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
            cardElement.style.left = dragState.originalPosition.x + 'px';
            cardElement.style.top = dragState.originalPosition.y + 'px';
            cardElement.style.transform = 'scale(1.0)';
            
            setTimeout(() => {
                callback();
            }, 300);
        }

        function resetDragState() {
            if (dragState.dragElement) {
                dragState.dragElement.classList.remove('dragging');
                dragState.dragElement.style.transition = '';
                dragState.dragElement.style.left = '';
                dragState.dragElement.style.top = '';
                dragState.dragElement.style.transform = '';
                dragState.dragElement.style.opacity = '';
            }
            
            dragState.isDragging = false;
            dragState.currentCard = null;
            dragState.originalPosition = null;
            dragState.dragElement = null;
        }

        // --- UTILITY FUNCTIONS ---
        function applyEffect(effect) {
             if (!effect) return;
             for (const [stat, value] of Object.entries(effect)) {
                if (stat === 'addCards') value.forEach(addCardToHand);
                else if (stat === 'unlockCharacter') {
                    characters[value].met = true;
                    updateCharacterVisibility();
                } else if (playerStats.hasOwnProperty(stat)) {
                    playerStats[stat] = Math.max(0, Math.min(100, playerStats[stat] + (typeof value === 'function' ? value() : value)));
                }
            }
        }
        
        function addCardToHand(cardType) {
            const cardData = cardDatabase[cardType];
            if (!cardData) return;
            if (cardData.unique && gameState.flags[`unique_${cardType}_found`]) return;
            if (cardData.unique) gameState.flags[`unique_${cardType}_found`] = true;
            if (gameState.hand.length >= 6) gameState.hand.shift();
            
            const newCard = JSON.parse(JSON.stringify(cardData));
            newCard.id = `${cardType}_${Date.now()}`;
            gameState.hand.push(newCard);
        }
        
        // å…¨æ–°çš„æ—¥è¨˜ç”Ÿæˆå‡½æ•¸
// é€™æ˜¯ generateDiaryEntry å‡½æ•¸çš„å®Œæ•´æ­£ç¢ºç‰ˆæœ¬
function generateDiaryEntry() {
    let diary = `ã€ç¬¬ ${gameState.day} å¤©æ—¥è¨˜ã€‘\n\n`;
    const log = gameState.dayLog.actionCounts;
    let hasSpecificContent = false; // ç”¨æ–¼åˆ¤æ–·æ˜¯å¦ç”Ÿæˆäº†ç‰¹æ®Šæ—¥è¨˜

    // --- è¦å‰‡ 1ï¼šæ ¹æ“šé«˜é »ç‡å‹•ä½œç”Ÿæˆæ—¥è¨˜ ---
    if (log.HOE && log.HOE >= 2) { // <-- å·²å°‡æ¢ä»¶å¾ 3 æ”¹ç‚º 2
        diary += "ä»Šå¤©ä¸åœåœ°æ®èˆé‹¤é ­é€²è¡Œé–‹å¢¾ï¼Œé›™æ‰‹éƒ½æ„Ÿè¦ºå¿«è¦ç£¨ç ´äº†ï¼ŒçœŸæ˜¯è¾›è‹¦çš„ä¸€å¤©ã€‚\n\n";
        hasSpecificContent = true;
    } else if (log.SEED_BAG && log.SEED_BAG >= 2) {
        diary += "ä»Šå¤©æ’­ä¸‹äº†å¾ˆå¤šç¨®å­ï¼Œçœ‹è‘—ç©ºè•©è•©çš„åœŸåœ°è¢«å¡«æ»¿ï¼Œå¿ƒä¸­ä¹Ÿå¤šäº†ä¸€çµ²æœŸå¾…ã€‚\n\n";
        hasSpecificContent = true;
    } else if (log.REST && log.REST >= 2) {
        diary += "æ„Ÿè¦ºç‰¹åˆ¥ç–²æ†Šï¼Œä»Šå¤©å¤§éƒ¨åˆ†æ™‚é–“éƒ½åœ¨ä¼‘æ¯ã€‚å¿…é ˆå¾—é¤Šè¶³ç²¾ç¥æ‰èƒ½æ‡‰ä»˜æ˜å¤©çš„å·¥ä½œã€‚\n\n";
        hasSpecificContent = true;
    }

    // --- è¦å‰‡ 2ï¼šæ ¹æ“šè§¸ç™¼çš„ç‰¹æ®Šäº‹ä»¶ç”Ÿæˆæ—¥è¨˜ ---
    // æª¢æŸ¥ä»Šå¤©æ˜¯å¦è§¸ç™¼äº†æ‰¾åˆ°æ°´äº•çš„äº‹ä»¶
    if (gameState.dayLog.eventsTriggered?.FOUND_WATER) {
        diary += "ä»Šå¤©åœ¨èŠ±åœ’çš„è§’è½æœ‰äº†æ„å¤–çš„ç™¼ç¾â€”â€”ä¸€å£èˆŠäº•ï¼é€™çµ¦äº†æˆ‘æ–°çš„å¸Œæœ›ï¼Œä¹Ÿè¨±æ˜å¤©é‚„èƒ½æ‰¾åˆ°äº›æœ‰ç”¨çš„æ±è¥¿ã€‚\n\n";
        hasSpecificContent = true;
    }
    // æª¢æŸ¥ä»Šå¤©æ˜¯å¦è§¸ç™¼äº†æ‰¾åˆ°ç§˜å¯†å°å¾‘çš„äº‹ä»¶
    if (gameState.dayLog.eventsTriggered?.HIDDEN_PATH) {
        diary += "åœ°åœ–ä¸Šçš„æ¨™è¨˜ç«Ÿç„¶æ˜¯çœŸçš„ï¼æˆ‘æ‰¾åˆ°äº†ä¸€æ¢éš±ç§˜çš„å°å¾‘ï¼Œé‚„ç™¼ç¾äº†ä¸€äº›è¢«äººéºå¿˜çš„èŠ±ç¨®ã€‚\n\n";
        hasSpecificContent = true;
    }

    // --- è¦å‰‡ 3ï¼šå¦‚æœæ²’æœ‰ç‰¹æ®Šæ—¥è¨˜ï¼Œå‰‡æ ¹æ“šç¶œåˆè¡¨ç¾ç”Ÿæˆé€šç”¨æ—¥è¨˜ ---
    if (!hasSpecificContent) {
        const totalWorkActions = (log.HOE || 0) + (log.SEED_BAG || 0) + (log.WATER || 0) + (log.PRUNING_SHEARS || 0);
        if (totalWorkActions >= 3) {
            diary += "ä»Šå¤©åŸ‹é ­è‹¦å¹¹ï¼Œé›–ç„¶ç–²æ†Šï¼Œä½†çœ‹åˆ°èŠ±åœ’çš„è®ŠåŒ–ï¼Œè¦ºå¾—ä¸€åˆ‡éƒ½å€¼å¾—ã€‚\n\n";
        } else if (totalWorkActions > 0) {
            diary += "ä»Šå¤©æŒ‰éƒ¨å°±ç­åœ°åšäº†ä¸€äº›åœ’è—å·¥ä½œï¼Œä¸å¥½ä¸å£ï¼Œå¹³æ·¡çš„ä¸€å¤©ã€‚\n\n";
        } else {
            diary += "ä»Šå¤©å¹¾ä¹æ²’æœ‰æ€éº¼æ‰“ç†èŠ±åœ’ï¼Œæ™‚é–“å°±é€™æ¨£æµé€äº†ã€‚æ˜å¤©å¿…é ˆå¾—åŠ æŠŠå‹äº†ã€‚\n\n";
        }
    }

    // --- è¦å‰‡ 4ï¼šæœ€å¾Œæ ¹æ“šç©å®¶ç‹€æ…‹æ·»åŠ ä¸€å¥çµèª ---
    if (playerStats.energy < 20) {
        diary += "æˆ‘ç¾åœ¨ç­‹ç–²åŠ›ç›¡ï¼Œæ„Ÿè¦ºçœ¼çš®éƒ½å¿«çœä¸é–‹äº†ã€‚";
    } else if (playerStats.patience < 40) {
        diary += "åœ‹ç‹çš„è€å¿ƒä¼¼ä¹æ‰€å‰©ç„¡å¹¾ï¼Œæˆ‘èƒ½æ¸…æ¥šåœ°æ„Ÿå—åˆ°å®ˆè¡›é‚£å†°å†·çš„è¦–ç·šã€‚";
    } else if (characters.maid.met && playerStats.favor > 30) {
        diary += "é‚£ä½ä¾å¥³çš„å–„æ„æ˜¯é€™å†°å†·åœ°æ–¹è£¡å”¯ä¸€çš„æº«æš–ã€‚";
    } else {
        diary += "æ˜å¤©åˆæœƒæ˜¯æ€æ¨£çš„ä¸€å¤©å‘¢ï¼Ÿ";
    }

    return diary;
}

        // --- UI RENDERING ---
        function showScreen(screenId) {
            ['startScreen', 'gameplayScreen', 'endScreen'].forEach(id => document.getElementById(id).classList.add('hidden'));
            document.getElementById(screenId).classList.remove('hidden');
        }

        function updateCharacterVisibility() {
            Object.keys(characters).forEach(key => {
                const charEl = document.getElementById(`char-${key}`);
                if (charEl) {
                    charEl.classList.toggle('hidden', !characters[key].met);
                    if (characters[key].met) {
                        charEl.querySelector('.character-avatar-text').textContent = characters[key].name;
                        charEl.classList.add('met');
                    }
                }
            });
        }

        function updateAllUI() {
            document.getElementById('dayCounter').textContent = `ç¬¬${gameState.day}å¤©`;
            ['Garden', 'Energy', 'Favor', 'Patience'].forEach(stat => {
                document.getElementById(`stat${stat}`).style.width = playerStats[stat.toLowerCase()] + '%';
            });
            updateGardenVisual();
            updateCharacterVisibility();
        }

        function updateGardenVisual() {
            const gardenEl = document.getElementById('pixelArtGarden');
            if (playerStats.garden >= 80) gardenEl.textContent = gardenVisuals.blooming;
            else if (playerStats.garden >= 40) gardenEl.textContent = gardenVisuals.budding;
            else if (playerStats.garden >= 20) gardenEl.textContent = gardenVisuals.cleared;
            else gardenEl.textContent = gardenVisuals.weedy;
        }

        function displayEvent(event) {
            document.getElementById('eventText').textContent = event.text;
            document.getElementById('eventCharacter').textContent = event.character || '';
            const choicesContainer = document.getElementById('eventChoices');
            choicesContainer.innerHTML = '';
            
            if (event.choices) {
                event.choices.forEach(choice => {
                    const btn = document.createElement('button');
                    btn.className = 'event-choice-btn';
                    btn.textContent = choice.text;
                    btn.onclick = () => handleEventChoice(choice);
                    choicesContainer.appendChild(btn);
                });
            } else {
                applyEffect(event.effect);
                setTimeout(() => {
                    gameState.currentEvent = null;
                    updateAllUI();
                    renderHand();
                    processNextEvent();
                }, 1500);
            }
            updateAllUI();
        }

        function renderHandAndSlots() {
            renderHand();
            renderSlots();
        }

        function renderHand() {
            const handArea = document.getElementById('handArea');
            handArea.innerHTML = '';
            gameState.hand.forEach(card => {
                const cardEl = document.createElement('div');
                cardEl.className = `card ${card.type}`;
                cardEl.id = card.id;
                const durabilityText = card.durability ? `è€:${card.durability}` : card.charges ? `æ¬¡:${card.charges}` : '';
                cardEl.innerHTML = `<div class="card-art">${card.art}</div><div class="card-name">${card.name}</div><div class="card-durability">${durabilityText}</div>`;
                handArea.appendChild(cardEl);
            });
            
            // é‡æ–°è®¾ç½®æ‹–æ‹½
            setTimeout(setupDragAndDrop, 50);
        }

        function renderSlots() {
            const slotsContainer = document.getElementById('verbSlots');
            slotsContainer.innerHTML = '';
            TIME_PERIODS.forEach((time, index) => {
                const slotEl = document.createElement('div');
                slotEl.id = `slot-${index}`;
                let classList = 'verb-slot';
                if (index === gameState.periodIndex && !gameState.currentEvent) classList += ' current';
                if (gameState.slotCards[index]) classList += ' used';
                slotEl.className = classList;
                slotEl.innerHTML = `<span class="verb-slot-time">${time}</span>` + (gameState.slotCards[index] ? `<span class="verb-slot-action">${gameState.slotCards[index].name}</span>` : '');
                slotsContainer.appendChild(slotEl);
            });
        }

        function restartGame() {
            // æ¸…ç†æ‹–æ‹½çŠ¶æ€
            if (dragState.isDragging) {
                resetDragState();
            }
            showScreen('startScreen');
        }

        // --- åˆå§‹åŒ– ---
        document.addEventListener('DOMContentLoaded', function() {
            // è®¾ç½®æŒ‰é’®äº‹ä»¶ç›‘å¬
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // æ˜¾ç¤ºå¼€å§‹å±å¹•
            showScreen('startScreen');
        });
    </script>
</body>
</html>